#!/bin/sh

<<0
        ::::::::: :::::::::::   :::   :::   :::::::::
       :+:    :+:    :+:      :+:+: :+:+:  :+:    :+:
      +:+    +:+    +:+     +:+ +:+:+ +:+ +:+    +:+
     +#++:++#+     +#+     +#+  +:+  +#+ +#++:++#+
    +#+           +#+     +#+       +#+ +#+
   #+#           #+#     #+#       #+# #+#
  ###       ########### ###       ### ###

                            raspberry pi music player
                                      -- -     -
0

PIMP_DPATH_MPV_WL="${PIMP_DPATH_MPV_WL-"$HOME/.cache/pimp/mpv_watch_later"}"
PIMP_DPATH_MUSIC="${PIMP_DPATH_MUSIC-"$HOME/Music"}"
PIMP_FPATH_PLAYLIST="${PIMP_FPATH_PLAYLIST-"$HOME/.cache/pimp/playlist"}"

export PIMP_DPATH_MPV_WL
export PIMP_DPATH_MUSIC
export PIMP_FPATH_PLAYLIST

arg="$(printf '%s\n' "$*" | sed 's/\w*//' | sed '/^$/d' | cut -d ' ' -f2-)"
prereq="pimp espeak ffplay mpv"

check_prereqs()
{
	#  description: ensures program prerequisites are in $PATH.

	local result=0

	printf '%s' "$*" | sed 's/$/\n/g' | sed 's/ /\n/g' | \
	while read -r i
	do
		if ! command -v "${i}" > /dev/null 2>&1
		then
			result=1
			printf 'pimp: prerequisite "%s" not found in $PATH\n' "${i}" >&2
		fi
	done

	return "${result}"
}

create_list()
{
	#  description: generates recursive file list of specified directory
	#               and saves output as playlist file.

	if ! [ -d "$(dirname "${PIMP_FPATH_PLAYLIST}")" ]
	then
		mkdir -p "$(dirname "${PIMP_FPATH_PLAYLIST}")" > /dev/null 2>&1
	fi

	if [ -d "${PIMP_DPATH_MUSIC}/$*" ]
	then
		local dpath_full="$(realpath "${PIMP_DPATH_MUSIC}/$*")"
		find -L "${dpath_full}" -type f | sort > "${PIMP_FPATH_PLAYLIST}"
	fi
}

item_play()
{
	#  description: plays contents of playlist file.

	pkill espeak
	pkill ffplay

	if ! [ -z "$*" ]
	then
		for i in "$*"
		do
			create_list "${i}"
			break
		done
	fi

	if [ -f "${PIMP_FPATH_PLAYLIST}" ]
	then
		clear
		printf 'pimp: initiating the slap... (⌐■_■)\n'

		if ! [ -d "${PIMP_DPATH_MPV_WL}" ]
		then
			mkdir -p "${PIMP_DPATH_MPV_WL}"
		fi

		item_sound play

		mpv \
			--term-title='pimp' \
			--msg-level=all=no,term-msg=status,statusline=status,cplayer=error,ffmpeg=fatal,ffmpeg/demuxer=error \
			--term-playing-msg='\nPlaying: ${filename}\n' \
			--audio-pitch-correction=no --af-add=scaletempo=speed=both \
			--display-tags= \
			--loop-file=no \
			--loop-playlist=inf \
			--no-audio-display \
			--no-video \
			--playlist="${PIMP_FPATH_PLAYLIST}" \
			--save-position-on-quit \
			--watch-later-directory="${PIMP_DPATH_MPV_WL}" \
			--watch-later-options-remove=pause \
			--shuffle \
			"$@"
	else
		printf 'pimp: playlist file not found: %s\n' "${PIMP_FPATH_PLAYLIST}" >&2
		return 1
	fi
}

item_sound()
{
	#  description: produces sound effects for auditory navigation.

	case "$@" in
		play)
			ffplay -f lavfi -i 'sine=frequency=1000:duration=0.025' \
				-autoexit -nodisp > /dev/null 2>&1
			;;
		select|*)
			ffplay -f lavfi -i 'sine=frequency=2000:duration=0.025' \
				-autoexit -nodisp > /dev/null 2>&1
			;;
	esac
}

list_dirs()
{
	clear

	find -L "${PIMP_DPATH_MUSIC}" -type d -printf '%P\n' | sort -r | sed '/^$/d' | sed '$a.' | \
	fzf -i -s -m -e \
		--header='pimp (dir)' \
		--header-first \
		--border=rounded \
		--color=fg:15,fg+:0,bg+:10,hl:9,hl+:1,border:11,gutter:1,header:11,prompt:7,info:8,query:15 \
		--prompt '> ' \
		--algo=v1 \
		--query="$*" \
		--literal \
		--cycle \
		--tac \
		--layout=reverse \
		--preview '(printf "%s" {} | sed "s/\//, /g" | espeak -a 250 -s 300 && pimp play-sound select)' \
		--preview-window 0% \
		--bind "enter:execute(pimp play {}; pimp play-sound select)" \
		--bind "double-click:execute(pimp play {}; pimp play-sound select)" \
		--bind 'change:first' \
		--bind 'backward-eof:execute-silent(printf clear | espeak -a 250 -s 300)' \
		--bind 'bspace:clear-query' \
		--bind 'home:first' \
		--bind 'end:last' \
		--bind 'tab:abort' \
		--bind 'insert:abort' \
		--bind 'alt-q:abort' \
		--bind 'ctrl-q:abort' \
		--bind 'f5:execute(pimp filter)' \
		--bind 'f6:execute(pimp play; pimp play-sound select)' \
		--bind 'f7:execute(pimp dir)+abort' \
		--bind 'f8:execute(/bin/sh -uc "rm -f "${PIMP_DPATH_MPV_WL}"/*")' \
		--bind 'tab:abort'
}

list_filter()
{
	#  ----------------------------------------------------------------
	#  purpose of general variables:
	#  ----------------------------------------------------------------
	#  
	#  var int_modtime_plist_*gen
	#  --------------------------
	#  allows for playing contents of playlist file, if modified. gets
	#  modified timestamp of ${PIMP_FPATH_PLAYLIST} before and after
	#  `fzf` invocation.
	#  
	#  ----------------------------------------------------------------
	#  purpose of "workaround" variables, due to mandatory "while read"
	#  loop processing of `fzf` output:
	#  ----------------------------------------------------------------
	#  
	#  var int_pimp_quit
	#  -----------------
	#  facilitiates user-requested termination of pimp without
	#  1) alteraton of playlist file; or 2) playing playlist file, if
	#  modified by another pimp instance while pimp filter was running.
	#  
	#  `exit`, within loop, behaves as `return` or `break`.
	#  
	#  var int_pimp_refresh
	#  --------------------
	#  facilitiates refresh of pimp filter without impacting
	#  resumption of music playback, which can happen due to playlist
	#  file alteration via loop processing.
	#  
	#  `exit`, within loop, behaves as `return` or `break`.
	#  
	#  var str_skip_plist_gen
	#  ----------------------
	#  facilitates user's wish to resume music playback without
	#  requiring a restart of pimp or re-selecting what to play.
	#  
	#  var i
	#  -----
	#  avoids processing of `grep` upon first loop iteration.

	local int_modtime_plist_pregen="$(stat --format '%Y' "${PIMP_FPATH_PLAYLIST}")"
	local int_pimp_quit="$(cat /dev/random | tr -dc '0-9' | fold -w 2 | head -n 1)"
	local int_pimp_refresh="$(cat /dev/random | tr -dc '0-9' | fold -w 2 | head -n 1)"
	local str_skip_plist_gen="$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 10 | head -n 1)"
	local i=0

	clear
	item_sound select

	find -L "${PIMP_DPATH_MUSIC}" -type f -printf '%P\n' | sort -r | sed '/^$/d' | \
	fzf -i -s -m -e \
		--header='pimp (filter)' \
		--header-first \
		--border=rounded \
		--color=fg:15,fg+:0,bg+:10,hl:9,hl+:1,border:11,gutter:12,header:11,prompt:7,info:8,query:15 \
		--prompt '> ' \
		--algo=v1 \
		--query="$*" \
		--literal \
		--cycle \
		--tac \
		--header-lines=0 \
		--layout=reverse \
		--bind 'enter:select-all+accept' \
		--bind 'double-click:select-all+accept' \
		--bind 'change:first' \
		--bind 'backward-eof:execute-silent(pimp play-sound play)' \
		--bind 'home:first' \
		--bind 'end:last' \
		--bind "esc:execute(printf '%s\n' "${int_pimp_quit}")+abort" \
		--bind "tab:execute(printf '%s\n' "${int_pimp_quit}")+abort" \
		--bind "insert:execute(printf '%s\n' "${int_pimp_quit}")+abort" \
		--bind "alt-q:execute(printf '%s\n' "${int_pimp_quit}")+abort" \
		--bind "ctrl-q:execute(printf '%s\n' "${int_pimp_quit}")+abort" \
		--bind "f5:execute(printf '%s\n' "${int_pimp_quit}")+abort" \
		--bind "f6:execute(printf '%s\n' "${str_skip_plist_gen}")+abort" \
		--bind "f7:execute(printf '%s\n' "${int_pimp_refresh}")+abort" \
		--bind 'f8:execute(/bin/sh -uc "rm -f "${PIMP_DPATH_MPV_WL}"/*")' | \
	while read -r f
	do
		if [ "${i}" == 0 ]
		then
			#  exit loop and quit filter:
			if printf '%s' "${f}" | grep -q "${int_pimp_quit}"
			then
				exit "$int_pimp_quit"
			fi

			#  exit loop and refresh filter:
			if printf '%s' "${f}" | grep -q "${int_pimp_refresh}"
			then
				exit "$int_pimp_refresh"
			fi

			#  resume playback and quit filter upon loop exit:
			if printf '%s' "${f}" | grep -q "${str_skip_plist_gen}"
			then
				item_play
				exit "$int_pimp_quit"
			fi
		fi

		#  delete playlist file if loop was
		#  not exited during first loop iteration:
		if [ "${i}" == 0 ]
		then
			rm -f "${PIMP_FPATH_PLAYLIST}"
		fi

		#  add absolute path of filtered files to playlist file:
		printf '%s/%s\n' "${PIMP_DPATH_MUSIC}" "${f}" >> "${PIMP_FPATH_PLAYLIST}"
		local i=$((${i}+1))
		continue
	done

	#  get exit code deriving from loop:
	local int_loop_return_code="$(echo $?)"

	#  quit filter:
	if [ "${int_loop_return_code}" == "${int_pimp_quit}" ]
	then
		return
	fi

	#  refresh filter:
	if [ "${int_loop_return_code}" == "${int_pimp_refresh}" ]
	then
		list_filter
		return
	fi
	
	#  get modified timestamp of playlist file:
	int_modtime_plist_postgen="$(stat --format '%Y' "${PIMP_FPATH_PLAYLIST}")"

	#  if no timestamp match, play contents of playlist file:
	if [ "${int_modtime_plist_postgen}" != "${int_modtime_plist_pregen}" ]
	then
		item_play
		return
	fi
}

if ! check_prereqs "${prereq}"
then
	exit 1
fi

if ! [ -d "${PIMP_DPATH_MUSIC}" ]
then
	printf 'pimp: music directory not found: %s\n' "${PIMP_DPATH_MUSIC}" >&2
	exit 1
fi

#  set title of terminal emulator:
printf "\033]0;pimp\007"

case "$1" in
	dir|d)
		list_dirs "${arg}"
		exit
		;;
	
	filter|f)
		list_filter "${arg}"
		exit
		;;

	play|slap|p)
		item_play "${arg}"
		exit
		;;

	play-sound)
		item_sound "${arg}"
		exit 
		;;
	
	*)
		#  default deliberately for car stereos:
		if [ -f "${PIMP_FPATH_PLAYLIST}" ]
		then
			item_play
		fi

		list_dirs
		exit
		;;
esac
