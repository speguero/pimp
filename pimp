#!/bin/sh

<<0
        ::::::::: :::::::::::   :::   :::   :::::::::
       :+:    :+:    :+:      :+:+: :+:+:  :+:    :+:
      +:+    +:+    +:+     +:+ +:+:+ +:+ +:+    +:+
     +#++:++#+     +#+     +#+  +:+  +#+ +#++:++#+
    +#+           +#+     +#+       +#+ +#+
   #+#           #+#     #+#       #+# #+#
  ###       ########### ###       ### ###

                            raspberry pi music player
                                      -- -     -
0

PIMP_DPATH_CACHE="${PIMP_DPATH_CACHE-"${HOME}/.cache/pimp"}"
PIMP_DPATH_MPV_WL="${PIMP_DPATH_MPV_WL-"${PIMP_DPATH_CACHE}/playback"}"
PIMP_DPATH_MUSIC="${PIMP_DPATH_MUSIC-"${HOME}/Music"}"
PIMP_FPATH_PLAYLIST="${PIMP_FPATH_PLAYLIST-"${PIMP_DPATH_CACHE}/playlist"}"

arg="$(printf '%s\n' "$*" | awk '{$1=""; print}' | sed 's/^[[:space:]]*//g')"
prereq="pimp espeak ffplay mpv"

export PIMP_DPATH_CACHE
export PIMP_DPATH_MPV_WL
export PIMP_DPATH_MUSIC
export PIMP_FPATH_PLAYLIST

check_prereqs()
{
	#  description: ensures program prerequisites are in ${PATH}.

	local result=0

	printf '%s' "$*" | sed 's/$/\n/g' | sed 's/ /\n/g' | \
	while read -r i
	do
		if ! command -v "${i}" > /dev/null 2>&1
		then
			result=1
			printf 'pimp: prerequisite "%s" not found in $PATH\n' "${i}" >&2
		fi
	done

	return "${result}"
}

get_f_mtime()
{
	#  description: gets modified epoch timestamp of file.

	local f="$1"
	local modtime
	local os="$(uname -s | tr '[:upper:]' '[:lower:]')"

	case "${os}" in
		linux)
			modtime="$(stat -c %Y "${f}")"
			printf '%s' "${modtime}"
			;;
		openbsd|*)
			modtime="$(stat -f %m "${f}")"
			printf '%s' "${modtime}"
			;;
	esac

	return 0
}

play_music()
{
	#  description: plays contents of playlist file.

	pkill espeak
	pkill ffplay
	
	local dname_target="$*"
	local dpath_mpv_wl="${PIMP_DPATH_MPV_WL}"
	local dpath_music="${PIMP_DPATH_MUSIC}"
	local dpath_pimp_cache="${PIMP_DPATH_CACHE}"
	local dpath_target
	local fpath_mpv_wl_autosave_script="${dpath_pimp_cache}/autosave.lua"
	local fpath_playlist="${PIMP_FPATH_PLAYLIST}"
	local os="$(uname -s | tr '[:upper:]' '[:lower:]')"

	if ! [ -d "${dpath_pimp_cache}" ]
	then
		mkdir -p "${dpath_pimp_cache}" > /dev/null 2>&1
	fi

	#  if selected from dir filter:
	if [ -n "${dname_target}" ]
	then
		#  generate recursive dir file list as playlist file content:
		if [ -d "${dpath_music}/${dname_target}" ]
		then
			dpath_target="$(realpath "${dpath_music}/${dname_target}")"
			find -L "${dpath_target}" -type f | sort -R > "${fpath_playlist}"
		else
			return 1
		fi
	fi

	if ! [ -f "${fpath_mpv_wl_autosave_script}" ]
	then
		print_mpv_wl_autosave_script > "${fpath_mpv_wl_autosave_script}"
	fi

	if [ -f "${fpath_playlist}" ]
	then
		clear

		case "${os}" in
			darwin|linux)
				printf '%spimp: initiating the slap... (⌐■_■)%s\n' "$(tput bold)" "$(tput sgr0)"
				;;
			*)
				#  accounting for lack of utf-8 console support on *bsd platforms:
				printf '%spimp: initiating the slap... %s\n' "$(tput bold)" "$(tput sgr0)"
				;;
		esac

		if ! [ -d "${dpath_mpv_wl}" ]
		then
			mkdir -p "${dpath_mpv_wl}"
		fi

		play_sound play

		mpv \
			--af-add=scaletempo=speed=both \
			--audio-pitch-correction=no \
			--display-tags= \
			--loop-file=no \
			--loop-playlist=inf \
			--msg-level=all=no,term-msg=status,statusline=status,cplayer=error,ffmpeg=fatal,ffmpeg/demuxer=error \
			--no-audio-display \
			--no-video \
			--playlist="${fpath_playlist}" \
			--save-position-on-quit \
			--script="${fpath_mpv_wl_autosave_script}" \
			--term-playing-msg='\nPlaying: ${filename}\n' \
			--term-title='pimp' \
			--watch-later-directory="${dpath_mpv_wl}" \
			--watch-later-options-remove=pause \
			"$()"
	else
		printf 'pimp: playlist file not found: %s\n' "${fpath_playlist}" >&2
		return 1
	fi
}

play_sound()
{
	#  description: produces sound effects for auditory navigation.

	case "$*" in
		delete)
			ffplay -f lavfi -i 'sine=frequency=500:duration=0.05' \
				-autoexit -nodisp > /dev/null 2>&1
			;;
		play)
			ffplay -f lavfi -i 'sine=frequency=1000:duration=0.05' \
				-autoexit -nodisp > /dev/null 2>&1
			;;
		select)
			ffplay -f lavfi -i 'sine=frequency=2000:duration=0.05' \
				-autoexit -nodisp > /dev/null 2>&1
			;;
	esac

	return $?
}

play_tts()
{
	#  description: enable text-to-speech for auditory navigation.

	local os="$(uname -s | tr '[:upper:]' '[:lower:]')"
	local s
	
	if [ -z "$*" ]
	then
		read -r s
	else
		s="$*"
	fi

	case "${os}" in
		linux)
			printf '%s' "${s}" | espeak -a 250 -s 300 || return 1
			;;
		*)
			printf '%s' "${s}" | espeak -a 250 -s 235 || return 1
			;;
	esac
}

show_dname_filter()
{
	local arg_fzf_preview
	local arg_fzf_query
	local arg_pimp_quiet="$(printf '%s' "$*" | awk '{print $1}' | grep '^-q$')"
	local dpath_music="${PIMP_DPATH_MUSIC}"
	
	#  facilitates removal of ${dpath_music} from pimp dir filter results:
	local int_dpath_sections="$(( $(printf '%s' "${dpath_music}" | sed 's/\// /g' | wc -w) + 2 ))"

	case "${arg_pimp_quiet}" in
		-q)
			#  disable auditory navigation:
			arg_fzf_query="$(printf '%s' "$*" | awk '{$1=""; print}' | sed 's/^[[:space:]]*//g')"
			
			(play_sound select &)
			;;
		*)
			arg_fzf_preview='printf "%s" {} | sed "s/\//, /g" | pimp play-tts && pimp play-sound select'
			arg_fzf_query="$(printf '%s' "$*" | sed 's/^[[:space:]]*//g')"

			if [ -n "${arg_fzf_query}" ]
			then
				(play_sound select &)
			fi
			;;
	esac

	clear
	printf "\033]0;pimp\007"  #  set terminal emulator title.

	find -L "${dpath_music}" -type d | \
	cut -d '/' -f "${int_dpath_sections}"- | sed '/^$/d' | sed '1i\
.
	' | sort -r | \
	fzf -i -s -m -e \
		--header 'pimp (dir)' \
		--header-first \
		--border rounded \
		--color fg:15,fg+:0,bg+:10,hl:9,hl+:1,border:11,gutter:1,header:11,prompt:7,info:8,query:15 \
		--prompt '> ' \
		--algo v1 \
		--query "${arg_fzf_query}" \
		--literal \
		--cycle \
		--tac \
		--layout reverse \
		--preview "${arg_fzf_preview}" \
		--preview-window 0% \
		--bind 'enter:execute(pimp rmwl; pimp play {}; pimp play-sound select)+clear-query' \
		--bind 'double-click:execute(pimp rmwl; pimp play {}; pimp play-sound select)+clear-query' \
		--bind 'change:first' \
		--bind 'backward-eof:execute-silent(pimp play-sound play)' \
		--bind 'bspace:clear-query' \
		--bind 'home:first' \
		--bind 'end:last' \
		--bind 'tab:abort' \
		--bind 'insert:abort' \
		--bind 'alt-q:abort' \
		--bind 'ctrl-q:abort' \
		--bind 'f5:execute(pimp file)' \
		--bind 'f6:execute(pimp play; pimp play-sound select)' \
		--bind "f7:execute(pimp dir ${arg_pimp_quiet})+abort" \
		--bind 'f8:execute(pimp rmwl)' \
		--bind 'tab:abort'
}

show_fpath_filter()
{
	#  ----------------------------------------------------------------
	#  purpose of general variables:
	#  ----------------------------------------------------------------
	#  
	#  var int_modtime_plist_*loop
	#  ---------------------------
	#  allows for playing contents of playlist file, if modified. gets
	#  modified timestamp of ${PIMP_FPATH_PLAYLIST} before and after
	#  `fzf` invocation.
	#  
	#  ----------------------------------------------------------------
	#  purpose of "workaround" variables, due to mandatory "while read"
	#  loop processing of `fzf` output:
	#  ----------------------------------------------------------------
	#  
	#  var int_pimp_quit
	#  -----------------
	#  facilitiates user-requested termination of pimp without
	#  1) alteraton of playlist file; or 2) playing playlist file, if
	#  modified by another pimp instance while pimp file filter was
	#  running.
	#  
	#  `exit`, within loop, behaves as `return` or `break`.
	#  
	#  var int_pimp_refresh
	#  --------------------
	#  facilitiates refresh of pimp file filter without impacting
	#  resumption of music playback, which can happen due to playlist
	#  file alteration via loop processing.
	#  
	#  `exit`, within loop, behaves as `return` or `break`.
	#  
	#  var str_skip_plist_gen
	#  ----------------------
	#  facilitates user's wish to resume music playback without
	#  requiring a restart of pimp or re-selecting what to play.
	#  
	#  var i
	#  -----
	#  avoids processing of `grep` upon first loop iteration.

	local dpath_music="${PIMP_DPATH_MUSIC}"
	local fpath_playlist="${PIMP_FPATH_PLAYLIST}"
	local i=0
	local int_dpath_sections="$(( $(printf '%s' "${dpath_music}" | sed 's/\// /g' | wc -w) + 2 ))"
	local int_loop_return_code
	local int_modtime_plist_preloop="$(get_f_mtime "${fpath_playlist}")"
	local int_modtime_plist_postloop
	local int_pimp_quit="$(cat /dev/random | tr -dc '1-9' | fold -w 2 | head -n 1)"
	local int_pimp_refresh="$(cat /dev/random | tr -dc '1-9' | fold -w 2 | head -n 1)"
	local str_skip_plist_gen="$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 10 | head -n 1)"
	
	clear
	printf "\033]0;pimp\007"  #  set terminal emulator title.
	(play_sound select &)

	find -L "${dpath_music}" -type f | \
	cut -d '/' -f "${int_dpath_sections}"- | sed '/^$/d' | sort -r | \
	fzf -i -s -m -e \
		--header 'pimp (file)' \
		--header-first \
		--border rounded \
		--color fg:15,fg+:0,bg+:10,hl:9,hl+:1,border:11,gutter:12,header:11,prompt:7,info:8,query:15 \
		--prompt '> ' \
		--algo v1 \
		--query "$*" \
		--literal \
		--cycle \
		--tac \
		--header-lines 0 \
		--layout reverse \
		--bind 'enter:select-all+accept' \
		--bind 'double-click:select-all+accept' \
		--bind 'change:first' \
		--bind 'backward-eof:execute-silent(pimp play-sound play)' \
		--bind 'home:first' \
		--bind 'end:last' \
		--bind "esc:execute(printf '%s\n'    ${int_pimp_quit})+abort" \
		--bind "tab:execute(printf '%s\n'    ${int_pimp_quit})+abort" \
		--bind "insert:execute(printf '%s\n' ${int_pimp_quit})+abort" \
		--bind "alt-q:execute(printf '%s\n'  ${int_pimp_quit})+abort" \
		--bind "ctrl-q:execute(printf '%s\n' ${int_pimp_quit})+abort" \
		--bind "f5:execute(printf '%s\n'     ${int_pimp_quit})+abort" \
		--bind "f6:execute(printf '%s\n'     ${str_skip_plist_gen})+abort" \
		--bind "f7:execute(printf '%s\n'     ${int_pimp_refresh})+abort" \
		--bind 'f8:execute(pimp rmwl)' | \
	while read -r f
	do
		if [ ${i} -eq 0 ]
		then
			#  exit loop and quit filter:
			if printf '%s' "${f}" | grep -q "${int_pimp_quit}"
			then
				exit "${int_pimp_quit}"
			fi

			#  exit loop and refresh filter:
			if printf '%s' "${f}" | grep -q "${int_pimp_refresh}"
			then
				exit "${int_pimp_refresh}"
			fi

			#  resume playback and quit filter upon loop exit:
			if printf '%s' "${f}" | grep -q "${str_skip_plist_gen}"
			then
				play_music
				show_fpath_filter
				exit "${int_pimp_quit}"
			fi
		fi

		#  delete playlist file if loop was
		#  not exited during first loop iteration:
		if [ ${i} -eq 0 ]
		then
			rm -f "${fpath_playlist}"
		fi

		#  add absolute path of filtered files to playlist file:
		printf '%s/%s\n' "${dpath_music}" "${f}" >> "${fpath_playlist}"
		i=$((${i}+1))
		continue
	done

	#  get exit code deriving from loop:
	int_loop_return_code="$(printf '%s' $?)"

	#  quit filter:
	if [ "${int_loop_return_code}" = "${int_pimp_quit}" ]
	then
		return
	fi

	#  refresh filter:
	if [ "${int_loop_return_code}" = "${int_pimp_refresh}" ]
	then
		show_fpath_filter
		return
	fi

	#  get timestamp of playlist file once more:
	int_modtime_plist_postloop="$(get_f_mtime "${fpath_playlist}")"

	#  if no match, shuffle and play contents of playlist file:
	if [ "${int_modtime_plist_postloop}" != "${int_modtime_plist_preloop}" ]
	then
		sort -R "${fpath_playlist}" -o "${fpath_playlist}"

		remove_mpvwl
		play_music
		show_fpath_filter
		return
	else
		return
	fi
}

remove_mpvwl()
{
	#  description: delete mpv watch_later cache.

	local dpath_mpv_wl="${PIMP_DPATH_MPV_WL}"

	sh -uc "rm -f \"${dpath_mpv_wl}\"/*"

	if [ -d "${dpath_mpv_wl}" ]
	then
		(play_sound delete &)
		return 0
	else
		printf 'pimp: contents of playback cache directory "%s" could not be deleted.\n' "${dpath_mpv_wl}" >&2
		return 1
	fi
}

print_mpv_wl_autosave_script()
{
	cat <<EOF
-- autosave.lua
-- ------------
-- 
-- Periodically saves watch_later data during mpv playback.

os        = require 'os'
mp        = require 'mp'
mp_opt    = require 'mp.options'
timer_opt = {save_period = 15} -- seconds per mpv watch_later cache save.

function add_wl()
	mp.commandv('write-watch-later-config')
end

function del_wl(data)
	if data.reason == 'eof' or data.reason == 'stop' then
		local playlist = mp.get_property_native('playlist')
		
		for i, entry in pairs(playlist) do
			if entry.id == data.playlist_entry_id then
				mp.commandv('delete-watch-later-config', entry.filename)
			end
		end
	end
end

mp_opt.read_options(timer_opt)
save_period_timer = mp.add_periodic_timer(timer_opt.save_period, add_wl)

mp.register_event('file-loaded', add_wl)
mp.register_event('start-file',  add_wl)
mp.register_event('end-file',    del_wl)
EOF
	
	return 0
}

if ! check_prereqs "${prereq}"
then
	exit 1
fi

if ! [ -d "${PIMP_DPATH_MUSIC}" ]
then
	printf 'pimp: music directory not found: %s\n' "${PIMP_DPATH_MUSIC}" >&2
	exit 1
fi

case "$1" in
	d|dir)
		show_dname_filter "${arg}"
		exit $?
		;;
	f|file)
		show_fpath_filter "${arg}"
		exit $?
		;;
	p|play|slap)
		play_music "${arg}"
		exit $?
		;;
	play-sound)
		play_sound "${arg}"
		exit $?
		;;
	play-tts)
		play_tts "${arg}"
		exit $?
		;;
	rmwl)
		remove_mpvwl
		exit $?
		;;
	*)
		if [ -f "${PIMP_FPATH_PLAYLIST}" ]
		then
			play_music
		fi

		show_dname_filter
		exit $?
		;;
esac
