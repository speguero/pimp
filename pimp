#!/bin/sh

<<0
        ::::::::: :::::::::::   :::   :::   :::::::::
       :+:    :+:    :+:      :+:+: :+:+:  :+:    :+:
      +:+    +:+    +:+     +:+ +:+:+ +:+ +:+    +:+
     +#++:++#+     +#+     +#+  +:+  +#+ +#++:++#+
    +#+           +#+     +#+       +#+ +#+
   #+#           #+#     #+#       #+# #+#
  ###       ########### ###       ### ###

                            raspberry pi music player
                                      -- -     -
0

PIMP_DPATH_MPV_WL="${PIMP_DPATH_MPV_WL-"$HOME/.cache/pimp/mpv_watch_later"}"
PIMP_DPATH_MUSIC="${PIMP_DPATH_MUSIC-"$HOME/Music"}"
PIMP_FPATH_PLAYLIST="${PIMP_FPATH_PLAYLIST-"$HOME/.cache/pimp/playlist"}"
prereq="pimp espeak ffplay mpv"

export PIMP_DPATH_MPV_WL
export PIMP_DPATH_MUSIC
export PIMP_FPATH_PLAYLIST

check_prereq()
{
	local result=0

	printf '%s' "$*" | sed 's/$/\n/g' | sed 's/ /\n/g' | \
	while read -r i
	do
		if ! command -v "${i}" > /dev/null 2>&1
		then
			result=1
			printf 'pimp: prerequisite "%s" not found\n' "${i}" >&2
		fi
	done

	return "${result}"
}

create_list()
{
	# description: generates recursive file list of specified directory
	#              and saves output as playlist file.

	if ! [ -d "$(dirname "${PIMP_FPATH_PLAYLIST}")" ]
	then
		mkdir -p "$(dirname "${PIMP_FPATH_PLAYLIST}")" > /dev/null 2>&1
	fi

	if [ -d "${PIMP_DPATH_MUSIC}/$*" ]
	then
		local dpath_full="$(realpath "${PIMP_DPATH_MUSIC}/$*")"
		find -L "${dpath_full}" -type f | sort > "${PIMP_FPATH_PLAYLIST}"
	fi
}

item_play()
{
	# description: plays playlist file.

	pkill espeak
	pkill ffplay

	if ! [ -z "$*" ]
	then
		for i in "$*"
		do
			create_list "${i}"
			break
		done
	fi

	if [ -f "${PIMP_FPATH_PLAYLIST}" ]
	then
		clear
		printf 'pimp: initiating the slap... (⌐■_■)\n\n'

		if ! [ -d "${PIMP_DPATH_MPV_WL}" ]
		then
			mkdir -p "${PIMP_DPATH_MPV_WL}"
		fi

		item_sound play

		mpv \
			--term-title='pimp' \
			--msg-level=all=error \
			--term-playing-msg='\nPlaying: ${filename}\n' \
			--audio-pitch-correction=no --af-add=scaletempo=speed=both \
			--display-tags= \
			--loop-file=no \
			--loop-playlist=inf \
			--no-audio-display \
			--no-video \
			--playlist="${PIMP_FPATH_PLAYLIST}" \
			--save-position-on-quit \
			--watch-later-directory="${PIMP_DPATH_MPV_WL}" \
			--watch-later-options-remove=pause \
			--shuffle \
			"$@"
	else
		printf 'pimp: cannot find %s\n' "${PIMP_FPATH_PLAYLIST}" >&2
		return 1
	fi
}

item_sound()
{
	# description: produces sound effects for auditory guidance /
	#              navigation.

	case "$@" in
		select)
			ffplay -f lavfi -i 'sine=frequency=2000:duration=0.025' \
				-autoexit -nodisp > /dev/null 2>&1
			;;
		play)
			ffplay -f lavfi -i 'sine=frequency=1000:duration=0.025' \
				-autoexit -nodisp > /dev/null 2>&1
			;;
		*)
			ffplay -f lavfi -i 'sine=frequency=2000:duration=0.025' \
				-autoexit -nodisp > /dev/null 2>&1
			;;
	esac
}

list_dirs()
{
	clear

	find -L "${PIMP_DPATH_MUSIC}" -type d -printf '%P\n' | sort -r | sed '/^$/d' | sed '$a.' | \
	fzf -i -s -m -e \
		--header='pimp' \
		--header-first \
		--border=rounded \
		--color=fg:7,bg:0,fg+:0,bg+:10,hl:9,hl+:1,border:10,gutter:0,header:10,prompt:7,info:10 \
		--prompt '> ' \
		--algo=v1 \
		--literal \
		--cycle \
		--tac \
		--no-mouse \
		--header-lines=0 \
		--layout=reverse \
		--preview '(printf "%s" {} | sed "s/\//, /g" | espeak -a 250 -s 300 && pimp play-sound select)' \
		--preview-window 0% \
		--bind "enter:execute(pimp play {}; pimp play-sound select)" \
		--bind 'change:first' \
		--bind 'backward-eof:execute-silent(printf clear | espeak -a 250 -s 300)' \
		--bind 'bspace:clear-query' \
		--bind 'home:first' \
		--bind 'end:last' \
		--bind 'insert:abort' \
		--bind 'alt-q:abort' \
		--bind 'ctrl-q:abort' \
		--bind 'f5:execute(pimp filter)' \
		--bind 'f6:execute(pimp play)' \
		--bind 'f7:execute(pimp dirs)+abort' \
		--bind 'tab:abort'
}

list_filter()
{
	#  descriptions:
	#
	#  var int_modtime_plist_*gen
	#  --------------------------
	#  retreives modified epoch timestamp of $PIMP_FPATH_PLAYLIST before
	#  and after `fzf` invocation, to determine whether the content of
	#  said file was updated upon termination of said program.
	#
	#  var str_skip_plist_gen
	#  ----------------------
	#  generates random string; used as output to facilitate a user's
	#  wish to resume music playback (when using the pimp filter)
	#  without selecting what music to play.
	#  
	#  cannot use `fzf --bind` for such a purpose due to loop processing
	#  of `fzf` output below. a conditional statement detecting a match
	#  between `fzf` output and this var serves as a workaround.
	#
	#  var i
	#  -----
	#  avoids unnecessary processing of `grep` upon the first loop.

	local int_modtime_plist_pregen="$(stat --format '%Y' "${PIMP_FPATH_PLAYLIST}")"
	local str_skip_plist_gen="$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 50 | head -n 1)"
	local i=0

	clear
	item_sound select

	find -L "${PIMP_DPATH_MUSIC}" -type f -printf '%P\n' | sort -r | sed '/^$/d' | \
	fzf -i -s -m -e \
		--header='pimp' \
		--header-first \
		--border=rounded \
		--color=fg+:0,bg+:10,hl:9,hl+:1,border:10,gutter:0,header:10,prompt:7,info:10 \
		--prompt '> ' \
		--algo=v1 \
		--literal \
		--cycle \
		--tac \
		--no-mouse \
		--header-lines=0 \
		--layout=reverse \
		--bind 'enter:select-all+accept+execute(rm -f "${PIMP_FPATH_PLAYLIST}")' \
		--bind 'change:first' \
		--bind 'backward-eof:execute-silent(printf clear | espeak -a 250 -s 300)' \
		--bind 'home:first' \
		--bind 'end:last' \
		--bind 'insert:abort' \
		--bind 'alt-q:abort' \
		--bind 'ctrl-q:abort' \
		--bind 'f5:abort' \
		--bind "f6:execute(echo "${str_skip_plist_gen}")+abort" \
		--bind 'tab:abort' | \
	while read -r f
	do
		if [ "${i}" == 0 ]
		then
			if printf '%s' "${f}" | grep -q "${str_skip_plist_gen}"
			then
				item_play
				exit $?
			fi
		fi

		printf '%s/%s\n' "${PIMP_DPATH_MUSIC}" "${f}" >> "${PIMP_FPATH_PLAYLIST}"
		local i=$((${i}+1))
		continue
	done

	int_modtime_plist_postgen="$(stat --format '%Y' "${PIMP_FPATH_PLAYLIST}")"

	if [ "${int_modtime_plist_postgen}" != "${int_modtime_plist_pregen}" ]
	then
		item_play
	fi
}

if ! check_prereq "${prereq}"
then
	exit 1
fi

if ! [ -d "${PIMP_DPATH_MUSIC}" ]
then
	printf 'pimp: music directory not found: %s\n' "${PIMP_DPATH_MUSIC}" >&2
	exit 1
fi

case "$1" in
	dirs|-d)
		list_dirs
		exit
		;;
	
	filter|-f)
		list_filter
		exit
		;;

	play|slap|-p)
		item_play "$2"
		exit $?
		;;

	play-sound)
		item_sound "$2"
		exit 
		;;
	
	*)
		if [ -f "${PIMP_FPATH_PLAYLIST}" ]
		then
			item_play
		fi

		list_dirs
		exit
		;;
esac
