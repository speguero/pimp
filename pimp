#!/bin/sh

<<0
        ::::::::: :::::::::::   :::   :::   :::::::::
       :+:    :+:    :+:      :+:+: :+:+:  :+:    :+:
      +:+    +:+    +:+     +:+ +:+:+ +:+ +:+    +:+
     +#++:++#+     +#+     +#+  +:+  +#+ +#++:++#+
    +#+           +#+     +#+       +#+ +#+
   #+#           #+#     #+#       #+# #+#
  ###       ########### ###       ### ###

                            raspberry pi music player
                                      -- -     -
0

arg="$(printf '%s\n' "$*" | awk '{$1=""; print}' | sed 's/^[[:space:]]*//g')"
prereq="pimp espeak ffplay fzf mpv"

PIMP_DPATH_CACHE="${PIMP_DPATH_CACHE-"${HOME}/.cache/pimp"}"
PIMP_DPATH_CONF="${PIMP_DPATH_CONF-"${HOME}/.config/pimp"}"
PIMP_DPATH_MPV_WL="${PIMP_DPATH_MPV_WL-"${PIMP_DPATH_CACHE}/playback"}"
PIMP_DPATH_MUSIC="${PIMP_DPATH_MUSIC-"${HOME}/Music"}"
PIMP_FPATH_PLAYLIST="${PIMP_FPATH_PLAYLIST-"${PIMP_DPATH_CACHE}/playlist"}"

check_prerequisites()
{
	#  ensures program prerequisites are in ${PATH}.

	local err=0
	local p                #   last program will not process without
	local programs="$* -"  # < placeholder at end of string.

	printf '%s' "${programs}" | tr '[:space:]' '\n' | ( \

		while read -r p
		do
			if ! command -v "${p}" > /dev/null 2>&1
			then
				if [ ${err} -eq 0 ]
				then
					printf 'pimp: list of prerequisite programs not found within $PATH:\n\n' >&2
					err=1
				fi
				
				printf '%s\n' " - ${p}" >&2
			fi
		done

		return "${err}"
	)

	return $?
}

create_program_dirs()
{
	#  create directories for program usage.

	local dpath_cache="${PIMP_DPATH_CACHE}"
	local dpath_conf="${PIMP_DPATH_CONF}"
	local dpath_mpv_wl="${PIMP_DPATH_MPV_WL}"

	if ! [ -d "${dpath_cache}" ]
	then
		mkdir -p "${dpath_cache}" > /dev/null 2>&1
	fi

	if ! [ -d "${dpath_conf}" ]
	then
		mkdir -p "${dpath_conf}" > /dev/null 2>&1
	fi

	if ! [ -d "${dpath_mpv_wl}" ]
	then
		mkdir -p "${dpath_mpv_wl}" > /dev/null 2>&1
	fi

	return
}

get_file_modtime()
{
	#  gets modified epoch timestamp of file.

	local f="$1"
	local modtime
	local os="$(uname -s | tr '[:upper:]' '[:lower:]')"

	case "${os}" in
		linux)
			modtime="$(stat -c %Y "${f}")"
			printf '%s' "${modtime}"
			;;
		openbsd|*)
			modtime="$(stat -f %m "${f}")"
			printf '%s' "${modtime}"
			;;
	esac

	return 0
}

play_music()
{
	#  plays contents of playlist file.

	pkill espeak
	pkill ffplay
	
	local dname_filter_selection="$*"  #  selection from dir filter.
	local dpath_cache="${PIMP_DPATH_CACHE}"
	local dpath_conf="${PIMP_DPATH_CONF}"
	local dpath_mpv_wl="${PIMP_DPATH_MPV_WL}"
	local dpath_music="${PIMP_DPATH_MUSIC}"
	local dpath_filter_selection
	local fpath_mpv_input_conf="${dpath_conf}/input.conf"
	local fpath_mpv_wl_autosave_script="${dpath_cache}/autosave.lua"
	local fpath_playlist="${PIMP_FPATH_PLAYLIST}"
	local os="$(uname -s | tr '[:upper:]' '[:lower:]')"

	create_program_dirs

	#  create config and script files:

	if ! [ -f "${fpath_mpv_wl_autosave_script}" ]
	then
		print_mpv_wl_autosave_script > \
			"${fpath_mpv_wl_autosave_script}"
	fi

	if ! [ -f "${fpath_mpv_input_conf}" ]
	then
		touch "${fpath_mpv_input_conf}"
	fi

	#  create playlist file:
	if [ -n "${dname_filter_selection}" ]
	then
		if [ -d "${dpath_music}/${dname_filter_selection}" ]
		then
			dpath_filter_selection="$(realpath "${dpath_music}/${dname_filter_selection}")"
			find -L "${dpath_filter_selection}" -type f > "${fpath_playlist}"
		else
			return 1
		fi
	fi

	#  begin music playback:
	if [ -f "${fpath_playlist}" ]
	then
		clear

		case "${os}" in
			darwin|linux)
				printf '%spimp: initiating the slap... (⌐■_■)%s\n' \
					"$(tput bold)" "$(tput sgr0)"
				;;
			*)
				#  accounting for lack of utf-8 console support on *bsd platforms:
				printf '%spimp: initiating the slap... %s\n' \
					"$(tput bold)" "$(tput sgr0)"
				;;
		esac

		sort -R "${fpath_playlist}" -o "${fpath_playlist}"
		play_sound play

		mpv \
			--af-add=scaletempo=speed=both \
			--audio-pitch-correction=no \
			--display-tags= \
			--input-conf="${fpath_mpv_input_conf}" \
			--loop-file=no \
			--loop-playlist=inf \
			--msg-level=all=no,term-msg=status,statusline=status,cplayer=error,ffmpeg=fatal,ffmpeg/demuxer=error \
			--no-audio-display \
			--no-video \
			--playlist="${fpath_playlist}" \
			--save-position-on-quit \
			--script="${fpath_mpv_wl_autosave_script}" \
			--term-playing-msg='\nPlaying: ${filename}\n' \
			--term-title='pimp' \
			--volume=100 \
			--volume-max=100 \
			--watch-later-directory="${dpath_mpv_wl}" \
			--watch-later-options-remove=pause \
			"$()"
	else
		printf 'pimp: playlist file not found: %s\n' "${fpath_playlist}" >&2
		return 2
	fi
}

play_sound()
{
	#  produces sound effects for auditory navigation.

	case "$*" in
		delete)
			ffplay -f lavfi -i 'sine=frequency=500:duration=0.05' \
				-autoexit -nodisp > /dev/null 2>&1
			;;
		play)
			ffplay -f lavfi -i 'sine=frequency=1000:duration=0.05' \
				-autoexit -nodisp > /dev/null 2>&1
			;;
		select)
			ffplay -f lavfi -i 'sine=frequency=2000:duration=0.05' \
				-autoexit -nodisp > /dev/null 2>&1
			;;
	esac

	return $?
}

play_tts()
{
	#  enable text-to-speech for auditory navigation.

	local os="$(uname -s | tr '[:upper:]' '[:lower:]')"
	local str
	
	if [ -z "$*" ]
	then
		read -r str
	else
		str="$*"
	fi

	case "${os}" in
		linux)
			printf '%s' "${str}" | espeak -a 250 -s 300 || return 1
			;;
		*)
			printf '%s' "${str}" | espeak -a 250 -s 235 || return 1
			;;
	esac
}

show_dname_filter()
{
	#  Shows recursive and interactive list of subdirectories to play.

	local arg_preview
	local arg_query
	local arg_quiet="$(printf '%s' "$*" | awk '{print $1}' | grep '^-q$')"
	local dpath_music="${PIMP_DPATH_MUSIC}"
	
	#  facilitates removal of ${dpath_music} from filter list:
	local int_dpath_sections="$(( $(printf '%s' "${dpath_music}" | sed 's/\// /g' | wc -w) + 2 ))"

	case "${arg_quiet}" in
		-q)
			#  stop tts navigation:
			arg_query="$(printf '%s' "$*" | awk '{$1=""; print}' | sed 's/^[[:space:]]*//g')"
			
			(play_sound select &)
			;;
		*)
			#  keep tts navigation:
			arg_preview='printf "%s" {} | sed "s/\//, /g" | pimp play-tts && pimp play-sound select'
			arg_query="$(printf '%s' "$*" | sed 's/^[[:space:]]*//g')"

			if [ -n "${arg_query}" ]
			then
				(play_sound select &)
			fi
			;;
	esac

	set_term_title

	find -L "${dpath_music}" -type d | \
	cut -d '/' -f "${int_dpath_sections}"- | sed '/^$/d' | sed '1i\
.
	' | sort -r | \
	fzf -i -s -m -e \
		--header 'pimp (dir)' \
		--header-first \
		--border rounded \
		--color fg:15,fg+:0,bg+:10,hl:9,hl+:1,border:11,gutter:1,header:11,prompt:7,info:8,query:15 \
		--prompt '> ' \
		--algo v1 \
		--query "${arg_query}" \
		--literal \
		--cycle \
		--tac \
		--layout reverse \
		--preview "${arg_preview}" \
		--preview-window 0% \
		--bind 'enter:execute(pimp rmwl; pimp play {}; pimp play-sound select)+clear-query' \
		--bind 'double-click:execute(pimp rmwl; pimp play {}; pimp play-sound select)+clear-query' \
		--bind 'change:first' \
		--bind 'backward-eof:execute-silent(pimp play-sound play)' \
		--bind 'bspace:clear-query' \
		--bind 'home:first' \
		--bind 'end:last' \
		--bind 'tab:abort' \
		--bind 'insert:abort' \
		--bind 'alt-q:abort' \
		--bind 'ctrl-q:abort' \
		--bind 'f5:execute(pimp file)' \
		--bind 'f6:execute(pimp play; pimp play-sound select)' \
		--bind "f7:execute(pimp dir ${arg_quiet})+abort" \
		--bind 'f8:execute(pimp rmwl)' \
		--bind 'tab:abort'
}

show_fpath_filter()
{
	#  Shows recursive and interactive list of files to play.

	local arg_query="$*"
	local cmd_pimp_quit='10_cmd_filter_quit'
	local cmd_pimp_refresh='20_cmd_filter_refresh'
	local cmd_pimp_resume_playback='30_cmd_resume_playback'
	local dpath_music="${PIMP_DPATH_MUSIC}"
	local fpath_playlist="${PIMP_FPATH_PLAYLIST}"
	local i=0
	local int_modtime_plist_preloop="$(get_file_modtime "${fpath_playlist}")"
	local int_modtime_plist_postloop

	#  facilitates removal of ${dpath_music} from filter list:
	local int_dpath_sections="$(( $(printf '%s' "${dpath_music}" | sed 's/\// /g' | wc -w) + 2 ))"

	set_term_title
	(create_program_dirs &)
	(play_sound select &)

	find -L "${dpath_music}" -type f | \
	cut -d '/' -f "${int_dpath_sections}"- | sed '/^$/d' | sort -r | \
	fzf -i -s -m -e \
		--header 'pimp (file)' \
		--header-first \
		--border rounded \
		--color fg:15,fg+:0,bg+:10,hl:9,hl+:1,border:11,gutter:12,header:11,prompt:7,info:8,query:15 \
		--prompt '> ' \
		--algo v1 \
		--query "${arg_query}" \
		--literal \
		--cycle \
		--tac \
		--header-lines 0 \
		--layout reverse \
		--bind 'enter:select-all+accept' \
		--bind 'double-click:select-all+accept' \
		--bind 'change:first' \
		--bind 'backward-eof:execute-silent(pimp play-sound delete)' \
		--bind 'alt-bspace:clear-query' \
		--bind 'home:first' \
		--bind 'end:last' \
		--bind "esc:execute(printf '%s\n'    ${cmd_pimp_quit})+abort" \
		--bind "tab:execute(printf '%s\n'    ${cmd_pimp_quit})+abort" \
		--bind "insert:execute(printf '%s\n' ${cmd_pimp_quit})+abort" \
		--bind "alt-q:execute(printf '%s\n'  ${cmd_pimp_quit})+abort" \
		--bind "ctrl-q:execute(printf '%s\n' ${cmd_pimp_quit})+abort" \
		--bind "f5:execute(printf '%s\n'     ${cmd_pimp_quit})+abort" \
		--bind "f6:execute(printf '%s\n'     ${cmd_pimp_resume_playback})+abort" \
		--bind "f7:execute(printf '%s\n'     ${cmd_pimp_refresh})+abort" \
		--bind 'f8:execute(pimp rmwl)' | ( \

		#  until `fzf` intuitively enables the processing of multi-line
		#  output, a while-read subshell, along with case and return
		#  statements, must be facilitated to mimick said program as it
		#  would normally behave (when handling single-line output).

		while read -r f
		do
			if [ ${i} -eq 0 ]
			then
				case "${f}" in
					"${cmd_pimp_quit}")
						return 10
						;;
					"${cmd_pimp_refresh}")
						return 20
						;;
					"${cmd_pimp_resume_playback}")
						return 30
						;;
					*)
						rm -f "${fpath_playlist}"
						;;
				esac
			fi

			#  create absolute path and add to playlist file:
			printf '%s/%s\n' "${dpath_music}" "${f}" >> "${fpath_playlist}"
			i=$((${i}+1))

			continue
		done

		return 0
	)

	case "$?" in
		10)
			return 0
			;;
		20)
			return 100
			;;
		30)
			play_music
			return 100
			;;
		*)
			int_modtime_plist_postloop="$(get_file_modtime "${fpath_playlist}")"

			if [ "${int_modtime_plist_postloop}" != "${int_modtime_plist_preloop}" ]
			then
				remove_mpvwl_cache
				play_music
				return 100
			else
				return 0
			fi
	esac
}

remove_mpvwl_cache()
{
	#  deletes mpv watch_later cache.

	set -u

	local dpath_mpv_wl="${PIMP_DPATH_MPV_WL}"

	if rm -f "${dpath_mpv_wl}"/* > /dev/null 2>&1
	then
		(play_sound delete &)
		return 0
	else
		printf 'pimp: playback cache files stored within "%s" could not be deleted.\n' \
			"${dpath_mpv_wl}" >&2
		return 1
	fi
}

set_term_title()
{
	clear
	printf "\033]0;pimp\007"  
}

print_mpv_wl_autosave_script()
{
	cat <<EOF
-- autosave.lua
-- ------------
-- 
-- Periodically saves watch_later data during mpv playback.

os        = require 'os'
mp        = require 'mp'
mp_opt    = require 'mp.options'
timer_opt = {save_period = 15} -- seconds per mpv watch_later cache save.

function add_wl()
	mp.commandv('write-watch-later-config')
end

function del_wl(data)
	if data.reason == 'eof' or data.reason == 'stop' then
		local playlist = mp.get_property_native('playlist')
		
		for i, entry in pairs(playlist) do
			if entry.id == data.playlist_entry_id then
				mp.commandv('delete-watch-later-config', entry.filename)
			end
		end
	end
end

mp_opt.read_options(timer_opt)
save_period_timer = mp.add_periodic_timer(timer_opt.save_period, add_wl)

mp.register_event('file-loaded', add_wl)
mp.register_event('start-file',  add_wl)
mp.register_event('end-file',    del_wl)
EOF
	
	return 0
}

print_usage()
{
	cat <<EOF
usage: pimp [d|f|h|p|dir|file|play|slap] [-q] [query]

  d, dir [-q] [query]
      Display recursive list of subdirectories to play within default
      music directory or PIMP_DPATH_MUSIC.

  f, file [query]
      Display recursive list of files to play within default music
      directory or PIMP_DPATH_MUSIC.

  p, play, slap
      Resume music playback of cached playlist file.

  -q
      Disable auditory navigation.
EOF

	return 1
}

if ! check_prerequisites "${prereq}"
then
	exit 2
fi

if ! [ -d "${PIMP_DPATH_MUSIC}" ]
then
	printf 'pimp: music directory not found: %s\n' \
		"${PIMP_DPATH_MUSIC}" >&2
	exit 2
fi

case "$1" in
	d|dir)
		show_dname_filter "${arg}"
		exit $?
		;;
	f|file)
		while :
		do
			show_fpath_filter "${arg}"

			case "$?" in
				100)
					continue
					;;
				*)
					exit $?
					;;
			esac
		done
		;;
	h|-h)
		print_usage
		exit $?
		;;
	p|play|slap)
		play_music "${arg}"
		exit $?
		;;
	play-sound)
		play_sound "${arg}"
		exit $?
		;;
	play-tts)
		play_tts "${arg}"
		exit $?
		;;
	rmwl)
		remove_mpvwl_cache
		exit $?
		;;
	*)
		if [ -f "${PIMP_FPATH_PLAYLIST}" ]
		then
			play_music
		fi

		show_dname_filter
		exit $?
		;;
esac
